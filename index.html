<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Korean Priming Experiment 2026</title>
  <style>
    html, body { height: 100%; font-family: system-ui, -apple-system, sans-serif; margin: 0; background: #fdfdfd; color: #333; }
    body { display: flex; justify-content: center; align-items: flex-start; padding: 24px; box-sizing: border-box; }
    
    .card { width: min(800px, 100%); border: 1px solid #ddd; border-radius: 16px; padding: 32px; background: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
    .hidden { display: none !important; }
    
    /* 상단 진행률 바 */
    #experimentHeader { width: 100%; margin-bottom: 24px; }
    .progress-container { width: 100%; background: #eee; border-radius: 10px; height: 10px; overflow: hidden; }
    #mainProgressBar { width: 0%; height: 100%; background: #4CAF50; transition: width 0.3s ease; }
    #trialCounter { text-align: right; font-size: 14px; margin-top: 8px; font-weight: 600; color: #666; }

    /* 실시간 마이크 입력 바 */
    .mic-monitor { margin-top: 20px; text-align: center; }
    .mic-gauge-container { width: 200px; height: 8px; background: #eee; border-radius: 4px; margin: 8px auto; overflow: hidden; border: 1px solid #ddd; }
    #liveMicFill { width: 0%; height: 100%; background: #2196F3; transition: width 0.05s linear; }
    
    /* 자극 제시 영역 */
    .stimulus-display { height: 400px; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
    #primingFixation { font-size: 72px; font-weight: 300; }
    #primingImg { max-width: 450px; max-height: 350px; object-fit: contain; }

    /* 버튼 및 입력 서식 */
    button { padding: 12px 24px; font-size: 16px; cursor: pointer; border-radius: 8px; border: 1px solid #ccc; background: #fff; transition: all 0.2s; }
    button:hover { background: #f0f0f0; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #btnAnimate, #btnInanimate { padding: 20px 40px; font-size: 20px; font-weight: bold; min-width: 150px; }
    #btnAnimate { border-color: #4CAF50; color: #2e7d32; }
    #btnInanimate { border-color: #f44336; color: #c62828; }
    
    input, select { width: 100%; padding: 10px; margin: 8px 0 20px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box; font-size: 16px; }
    label { font-weight: bold; display: block; }
    .note { font-size: 14px; color: #666; line-height: 1.5; }
    #primingStatus { text-align: center; font-weight: bold; font-size: 22px; margin-top: 15px; min-height: 1.2em; color: #d32f2f; }
  </style>
</head>
<body>

<div class="card" id="screen-consent">
  <h1 style="margin-top:0;">연구 참여 동의</h1>
  <p class="note">
    본 실험은 그림을 보고 단어를 말하거나 생물/무생물을 판단하는 과제입니다. [cite: 1, 2]<br>
    반응시간과 음성이 녹음되어 서버에 저장됩니다. [cite: 1, 2]<br>
    중간에 잦은 오류가 발생하거나 응답이 없을 경우 실험이 자동 종료될 수 있습니다.
  </p>
  <label><input type="checkbox" id="consentCheck"> 연구 참여에 동의합니다.</label>
  <hr>
  <label>닉네임 (실명X)</label><input id="nick" placeholder="예: HJ">
  <label>생년월</label><input id="birthYM" type="month">
  <label>성별</label>
  <select id="gender"><option value="">선택</option><option value="male">남</option><option value="female">여</option></select>
  <label>모국어</label><input id="nativeLang" value="한국어">
  <label>기타 외국어</label><input id="otherLangs" placeholder="없을 시 '없음'">
  <button id="btnStart" disabled>실험 시작</button>
</div>

<div class="card hidden" id="screen-priming">
  <div id="experimentHeader">
    <div class="progress-container"><div id="mainProgressBar"></div></div>
    <p id="trialCounter">0 / 108</p>
  </div>

  <div class="stimulus-display">
    <div id="primingFixation" class="hidden">+</div>
    <img id="primingImg" class="hidden">
  </div>

  <div class="mic-monitor">
    <span style="font-size:12px; color:#666;">마이크 입력 상태</span>
    <div class="mic-gauge-container"><div id="liveMicFill"></div></div>
  </div>

  <p id="primingStatus"></p>

  <div id="animacyButtons" class="hidden" style="margin-top:20px; display:flex; gap:20px; justify-content:center;">
    <button id="btnAnimate">생물</button>
    <button id="btnInanimate">무생물</button>
  </div>
</div>

<div class="card hidden" id="screen-contact">
  <h2>실험 종료</h2>
  <p>모든 과제를 마쳤습니다. 보상 지급을 위해 연락처를 입력해 주세요.</p>
  <label>휴대폰 번호</label>
  <input id="contactValue" placeholder="010-0000-0000">
  <button id="btnSubmitContact">제출하고 완료</button>
</div>

<script type="module">
  import { jsonp, createSession, appendRow, uploadAudioBlob } from "./js/api.js";

  /* 상태 변수 */
  let session = null;
  let assignedGroup = "overt"; // 기본값
  let currentTrials = [];
  let timeoutCount = 0;
  let uploadFailCount = 0;
  const FAIL_LIMIT = 10;
  const TOTAL_TRIALS_NUM = 108;

  /* DOM 요소 */
  const screens = {
    consent: document.getElementById("screen-consent"),
    priming: document.getElementById("screen-priming"),
    contact: document.getElementById("screen-contact")
  };
  const primingStatus = document.getElementById("primingStatus");
  const liveMicFill = document.getElementById("liveMicFill");

  /* 1. 세션 준비 및 리스트 로드 */
  async function initExperiment() {
    // 3개 리스트 중 하나 무작위 선택
    const listNum = Math.floor(Math.random() * 3) + 1;
    const response = await fetch(`./stim/pairs_list_${listNum}.csv`);
    const text = await response.text();
    currentTrials = parseCSV(text);
    
    // 그룹 할당 (overt/covert/nonaming 중 무작위) [cite: 33]
    const groups = ["overt", "covert", "nonaming"];
    assignedGroup = groups[Math.floor(Math.random() * groups.length)];
  }

  function parseCSV(text) {
    const lines = text.trim().split("\n");
    const headers = lines[0].split(",");
    return lines.slice(1).map(line => {
      const values = line.split(",");
      return headers.reduce((obj, h, i) => ({ ...obj, [h.trim()]: values[i].trim() }), {});
    });
  }

  /* 2. 실시간 마이크 모니터링 */
  function startMicMonitoring() {
    if (!window.analyser) return;
    const dataArray = new Uint8Array(window.analyser.fftSize);
    
    function updateBar() {
      if (screens.priming.classList.contains("hidden")) return;
      window.analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = (dataArray[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / dataArray.length);
      liveMicFill.style.width = Math.min(100, rms * 800) + "%";
      requestAnimationFrame(updateBar);
    }
    updateBar();
  }

  /* 3. 녹음 로직 (3초 고정) */
  async function recordThreeSeconds() {
    const chunks = [];
    const recorder = new MediaRecorder(window.micStream);
    recorder.ondataavailable = e => chunks.push(e.data);
    recorder.start();

    // 음성 인식(onset) 감지는 병렬 수행
    const onsetPromise = detectVoiceOnset(3000, 0.02);

    await new Promise(r => setTimeout(r, 3000)); // 3초 대기 
    recorder.stop();
    const onset = await onsetPromise;
    const blob = await new Promise(r => {
      recorder.onstop = () => r(new Blob(chunks, { type: "audio/webm" }));
    });
    return { onset, blob };
  }

  async function detectVoiceOnset(maxMs, threshold) {
    const start = performance.now();
    const dataArray = new Uint8Array(window.analyser.fftSize);
    return new Promise(resolve => {
      function check() {
        window.analyser.getByteTimeDomainData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          const v = (dataArray[i] - 128) / 128;
          sum += v * v;
        }
        if (Math.sqrt(sum / dataArray.length) > threshold) {
          resolve(Math.round(performance.now() - start));
        } else if (performance.now() - start > maxMs) {
          resolve(null);
        } else {
          requestAnimationFrame(check);
        }
      }
      check();
    });
  }

  /* 4. 실험 중단 처리 */
  function failAndTerminate(msg) {
    alert(`실험 중단: ${msg}\n환경을 점검하고 다시 시작해 주세요.`);
    location.reload();
  }

  /* 5. 메인 루프 */
  async function runExperiment() {
    screens.consent.classList.add("hidden");
    screens.priming.classList.remove("hidden");
    startMicMonitoring();

    for (let i = 0; i < currentTrials.length; i++) {
      const trial = currentTrials[i];
      
      // UI 업데이트
      document.getElementById("mainProgressBar").style.width = ((i / TOTAL_TRIALS_NUM) * 100) + "%";
      document.getElementById("trialCounter").textContent = `${i + 1} / ${TOTAL_TRIALS_NUM}`;
      
      // Fixation (300ms)
      document.getElementById("primingFixation").classList.remove("hidden");
      await new Promise(r => setTimeout(r, 300));
      document.getElementById("primingFixation").classList.add("hidden");

      // Prime 제시
      const img = document.getElementById("primingImg");
      img.src = `./stim/${trial.prime_pic}`; // pairs.csv의 prime_pic 필드 사용 
      img.classList.remove("hidden");
      
      if (assignedGroup === "overt") {
        primingStatus.textContent = "말하세요";
        await recordThreeSeconds(); // 분석용이나 업로드는 생략 가능(필요시 추가)
      } else if (assignedGroup === "nonaming") {
        primingStatus.textContent = "생물인가요?";
        document.getElementById("animacyButtons").classList.remove("hidden");
        await new Promise(r => {
          document.getElementById("btnAnimate").onclick = () => r();
          document.getElementById("btnInanimate").onclick = () => r();
        });
        document.getElementById("animacyButtons").classList.add("hidden");
      } else {
        await new Promise(r => setTimeout(r, 1500));
      }
      
      img.classList.add("hidden");
      primingStatus.textContent = "";
      await new Promise(r => setTimeout(r, 200)); // ISI

      // Target 제시
      img.src = `./stim/${trial.target_pic}`;
      img.classList.remove("hidden");
      primingStatus.textContent = "빨리 말하세요!";

      const targetData = await recordThreeSeconds();
      
      // 타임아웃 체크
      if (targetData.onset === null) {
        timeoutCount++;
        if (timeoutCount >= FAIL_LIMIT) return failAndTerminate("반복적인 무응답");
      }

      // 업로드 (비동기 처리)
      const meta = {
        pid: session.pid,
        sessionId: session.sessionId,
        folderId: session.folderId,
        filename: `${session.pid}_T${i}_target.webm`,
        trialId: trial.pair_id,
        phase: "priming",
        type: "target"
      };

      uploadAudioBlob(targetRec.blob, meta).catch(() => {
        uploadFailCount++;
        if (uploadFailCount >= FAIL_LIMIT) failAndTerminate("연결 오류 및 업로드 실패");
      });

      img.classList.add("hidden");
      primingStatus.textContent = "";
      await new Promise(r => setTimeout(r, 800)); // ITI
    }

    screens.priming.classList.add("hidden");
    screens.contact.classList.remove("hidden");
  }

  /* 초기 이벤트 바인딩 */
  document.getElementById("btnStart").onclick = async () => {
    try {
      window.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      window.analyser = audioCtx.createAnalyser();
      audioCtx.createMediaStreamSource(window.micStream).connect(window.analyser);
      
      const pid = "P" + Date.now();
      session = await createSession(pid, { primeModeGroup: assignedGroup }); [cite: 30, 31, 32]
      await initExperiment();
      runExperiment();
    } catch (e) {
      alert("마이크 권한이 필요합니다.");
    }
  };

  document.getElementById("consentCheck").onchange = e => {
    document.getElementById("btnStart").disabled = !e.target.checked;
  };

  document.getElementById("btnSubmitContact").onclick = async () => {
    const val = document.getElementById("contactValue").value;
    if (!val) return alert("연락처를 입력해 주세요.");
    await jsonp({
      action: "appendContact",
      contact_json: JSON.stringify({ pid: session.pid, sessionId: session.sessionId, contact_value: val }) [cite: 49, 50, 51]
    });
    alert("감사합니다. 실험이 종료되었습니다.");
    location.href = "about:blank";
  };
</script>

</body>
</html>
