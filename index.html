<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Experiment</title>
  <style>
    html, body {
      height: 100%;
    }
    
    body{
      font-family: system-ui, sans-serif;
      margin: 0;
    
      display: flex;
      justify-content: center;   /* ê°€ë¡œ ì¤‘ì•™ */
      align-items: flex-start;   /* ì„¸ë¡œëŠ” ìœ„ì—ì„œ ì‹œì‘ */
    
      padding: 24px;             /* í™”ë©´ ê°€ì¥ìë¦¬ ì—¬ë°± */
      box-sizing: border-box;
    
      background: #fff;
    }
    .card{
      width: min(760px, 100%);
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 16px;
      margin: 0 0 24px 0;   /* ì•„ë˜ìª½ ê°„ê²©ë§Œ */
    }
    .hidden { display: none; }
    /* ===== 4AFC choice layout ===== */
    #afcChoices{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 16px;
    }
  
    #afcChoices button{
      width:100%;
      padding: 12px;
      font-size: 16px;
    }
    label { display:block; margin: 10px 0 6px; }
    input, select { width: 100%; padding: 8px; font-size: 16px; }
    button { padding: 10px 14px; font-size: 16px; cursor: pointer; }
    .note { font-size: 14px; color:#444; }
    .loadingBox { margin-top: 12px; padding: 10px; background:#f7f7f7; border-radius:10px; }
    .study-instruction {
      font-size: 16px;      /* consent ë¬¸êµ¬ë‘ ë¹„ìŠ·í•œ í¬ê¸° */
      line-height: 1.6;
      color: #000;          /* íšŒìƒ‰ ë§ê³  ê²€ì • */
    }
    .spinner {
      display:inline-block; width:14px; height:14px;
      border:2px solid #ccc; border-top-color:#333;
      border-radius:50%; animation:spin 0.8s linear infinite;
      margin-right:8px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>

<body>


<!-- ================== 1. Consent + Participant Info ================== -->
<div class="card" id="screen-consent">
  <h1 style="margin-top:0;">ì‹¤í—˜ ì°¸ì—¬</h1>
  <h2>ì—°êµ¬ ì°¸ì—¬ ë™ì˜</h2>
  <p>
    ì´ ì‹¤í—˜ì—ì„œëŠ” ê·¸ë¦¼ì„ ë³´ê³  ë‹¨ì–´ë¥¼ ë§í•˜ê±°ë‚˜ ì„ íƒí•˜ëŠ” ê³¼ì œë¥¼ í•˜ê²Œ ë©ë‹ˆë‹¤.<br>
    ê° ë‹¨ê³„ë§ˆë‹¤ í™”ë©´ì— ì•ˆë‚´ê°€ ì œì‹œë©ë‹ˆë‹¤. ì•ˆë‚´ì— ë”°ë¼ ì§„í–‰í•´ ì£¼ì„¸ìš”.<br><br>
    ì‹¤í—˜ì€ ì—¬ëŸ¬ ë‹¨ê³„ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.<br>
    ê° ë‹¨ê³„ì—ì„œ ì§‘ì¤‘í•´ì„œ í™”ë©´ì„ ë³´ê³  ë°˜ì‘í•´ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤.<br>
    ì •ë‹µ ì—¬ë¶€ëŠ” ì‹¤í—˜ ì¤‘ì— ì•Œë ¤ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.<br><br>
    ë°˜ì‘ì‹œê°„ê³¼ ìŒì„±(ë…¹ìŒ)ì´ ìˆ˜ì§‘ë©ë‹ˆë‹¤.<br>
    ìŒì„± ë…¹ìŒì„ ìœ„í•´ ë§ˆì´í¬ ì„¸íŒ…ì„ í™•ì¸í•˜ê³  ì‹¤í—˜ì„ ì‹œì‘í•´ì£¼ì„¸ìš”.<br>
    ì–¸ì œë“  ì¤‘ë‹¨í•  ìˆ˜ ìˆìœ¼ë©°, ë™ì˜í•˜ì§€ ì•Šìœ¼ë©´ ì°¸ì—¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
  </p>

  <label>
    <input type="checkbox" id="consentCheck">
    ìœ„ ë‚´ìš©ì„ ì½ì—ˆê³  ì—°êµ¬ ì°¸ì—¬ì— ë™ì˜í•©ë‹ˆë‹¤.
  </label>

  <hr>

  <h3>ì°¸ê°€ì ì •ë³´</h3>

  <label>ë‹‰ë„¤ì„ / ì´ë‹ˆì…œ (2ê¸€ì ì´ìƒ)</label>
  <input id="nick" placeholder="ì˜ˆ: HJ, MS (ì‹¤ëª… X)">

  <label>ìƒë…„ì›”</label>
  <input id="birthYM" type="month">

  <label>ëª¨êµ­ì–´</label>
  <input id="nativeLang" placeholder="ì˜ˆ: í•œêµ­ì–´">

  <label>ì™¸êµ­ì–´(ë“¤)</label>
  <input id="otherLangs" placeholder="ì˜ˆ: ì˜ì–´, ì¼ë³¸ì–´ (ì—†ìœ¼ë©´ 'ì—†ìŒ')">

  <button id="btnStart" disabled>ë™ì˜í•˜ê³  ì‹œì‘</button>

  <div id="loading" class="loadingBox hidden">
    <div><span class="spinner"></span><b>ì„¸ì…˜ì„ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤â€¦</b></div>
    <div class="note">ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.</div>
  </div>
</div>

<!-- ================== Ready ================== -->
<div class="card hidden" id="screen-ready">
  <h2>ì¤€ë¹„ ì™„ë£Œ</h2>
  <p>ì´ì œë¶€í„° ì‹¤í—˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.</p>
  <button id="btnContinue">ê³„ì†</button>
</div>

  <!-- ================== 2. Study ================== -->
<div class="card hidden" id="screen-study">
  <h2>í•™ìŠµ(Study)</h2>
  <p class="note study-instruction" id="studyProgress">
    ì´ í•™ìŠµ ë‹¨ê³„ì—ì„œëŠ” ê·¸ë¦¼ê³¼ í•¨ê»˜ í•´ë‹¹í•˜ëŠ” ë‹¨ì–´ë¥¼ ë¯¸ë¦¬ ë³´ì—¬ë“œë¦½ë‹ˆë‹¤.<br>
    ì´í›„ ë‹¨ê³„ì—ì„œëŠ” ê¸€ìê°€ ì—†ì´ ê·¸ë¦¼ë§Œ ì œì‹œë˜ê¸° ë•Œë¬¸ì—,<br>
    ê·¸ë¦¼ê³¼ ë‹¨ì–´ì˜ ì—°ê²°ì„ ì˜ ìµí˜€ ì£¼ì„¸ìš”.  <br><br>
    ê° ê·¸ë¦¼ì€ ì ê¹ì”© ìë™ìœ¼ë¡œ ì œì‹œë©ë‹ˆë‹¤.<br>
    í™”ë©´ì— ë‚˜ì˜¤ëŠ” ê·¸ë¦¼ê³¼ ë‹¨ì–´ë¥¼ ê·¸ëŒ€ë¡œ ë³´ê³  ê¸°ì–µí•´ ì£¼ì„¸ìš”.<br>
    í•™ìŠµì€ ë¹ ë¥´ê²Œ 2íšŒ ë°˜ë³µë©ë‹ˆë‹¤.<br><br>
    í•™ìŠµì´ ëë‚˜ë©´, ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™í•˜ëŠ” ë²„íŠ¼ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.
  </p>

  <!-- ğŸ”’ ê³ ì • ë†’ì´ ì‹œê° ì˜ì—­ -->
  <div style="
    height:380px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
  ">
    <div id="fixation" class="hidden" style="font-size:48px;">+</div>
    <img id="studyImg" class="hidden" style="max-width:420px; max-height:320px;">
    <div id="studyLabel" class="hidden" style="font-size:28px; margin-top:10px;"></div>
  </div>

  <!-- ğŸ”’ ë²„íŠ¼ì€ í•­ìƒ ê°™ì€ ìœ„ì¹˜ -->
  <div style="margin-top:16px; text-align:center;">
    <button id="btnStartStudy">í•™ìŠµ ì‹œì‘</button>
    <button id="btnNextAfterStudy" class="hidden">ë‹¤ìŒ (4ì§€ì„ ë‹¤ í…ŒìŠ¤íŠ¸)
    </button>
  </div>
</div>
  
<!-- ================== 2-2. Study test- 4AFC ================== -->
<div class="card hidden" id="screen-afc">
  <h2>4ì§€ì„ ë‹¤ í…ŒìŠ¤íŠ¸</h2>
  <p class="note" id="afcProgress">
    ì œì‹œë˜ëŠ” ê·¸ë¦¼ì— í•´ë‹¹í•˜ëŠ” ë‹¨ì–´ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.
  </p>

  <div style="text-align:center;">
    <img id="afcImg" style="max-width:420px; max-height:320px;" />
  </div>

  <div id="afcChoices"></div>
  <p class="note" id="afcTimer"></p>

  <button id="btnNextAFC" class="hidden">ë‹¤ìŒ</button>
</div>

<!-- ================== 2-3. 4AFC ê²°ê³¼/ë¶„ê¸° ================== -->
<div class="card hidden" id="screen-afc-result">
  <h2>í™•ì¸ í…ŒìŠ¤íŠ¸ ê²°ê³¼</h2>
  <p id="afcResultText"></p>

  <div id="afcResultButtons" style="margin-top:16px; text-align:center;">
    <button id="btnAfcRemedial" class="hidden">ì˜¤ë‹µë§Œ ë‹¤ì‹œ í•™ìŠµí•˜ê³  ì¬ì‹œí—˜</button>
    <button id="btnAfcProceed" class="hidden">ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰</button>
  </div>
</div>

<!-- ================== Mic Calibration ================== -->
<div class="card hidden" id="screen-mic">
  <h2>ë§ˆì´í¬ í™•ì¸</h2>
  <p class="note" id="micText"></p>

  <div style="margin-top:12px;">
    <progress id="micMeter" value="0" max="1" style="width:100%; height:18px;"></progress>
    <div class="note" id="micLevelText"></div>
  </div>

  <div style="margin-top:16px; text-align:center;">
    <button id="btnMicStart">ë§ˆì´í¬ ê¶Œí•œ í™•ì¸</button>
    <button id="btnMicNext" class="hidden">ë³¸ ì‹¤í—˜ ì‹œì‘</button>
  </div>
</div>

<!-- ================== 3. Priming (ë³¸ ì‹¤í—˜) ================== -->
<div class="card hidden" id="screen-priming">
  <h2>ë³¸ ì‹¤í—˜</h2>

  <p class="note" id="primingInstruction"></p>

  <!-- ê³ ì • ë†’ì´ ì‹œê° ì˜ì—­ -->
  <div style="
    height:420px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:48px;
  ">
    <div id="primingFixation" class="hidden">+</div>
    <img id="primingImg" class="hidden" style="max-width:420px; max-height:320px;">
  </div>

  <p class="note" id="primingStatus"></p>

  <div id="animacyButtons" class="hidden" style="margin-top:12px;">
    <button id="btnAnimate">ìƒë¬¼</button>
    <button id="btnInanimate">ë¬´ìƒë¬¼</button>
  </div>
</div>
  

  
<!-- ================== 4. Contact (PII separated) ================== -->
<div class="card hidden" id="screen-contact">
  <h2>ë³´ìƒìš© ì—°ë½ì²˜</h2>
  <p class="note">
    ì´ ì •ë³´ëŠ” ì‹¤í—˜ ë°ì´í„°ì™€ ë¶„ë¦¬ë˜ì–´ ì €ì¥ë˜ë©°,<br>
    ë³´ìƒ ì§€ê¸‰ í›„ ì‚­ì œë©ë‹ˆë‹¤.
  </p>

  <label for="contactValue">ë³´ìƒìš© íœ´ëŒ€í° ë²ˆí˜¸</label>
<input id="contactValue"
       placeholder="ì˜ˆ: 010-1234-5678"
       inputmode="numeric"
       autocomplete="tel"
       autocorrect="off"
       autocapitalize="off" />
<div class="note">
  ë³´ìƒ ë°œì†¡ ëª©ì ì—ë§Œ ì‚¬ìš©ë˜ë©°, ì‹¤í—˜ ë°ì´í„°ì™€ ë¶„ë¦¬ ì €ì¥ë©ë‹ˆë‹¤.
</div>

  <button id="btnSubmitContact">ì œì¶œí•˜ê³  ì¢…ë£Œ</button>
</div>

<!-- ================== JS LOGIC ================== -->
<script type="module">
import { jsonp, createSession, appendRow } from "./js/api.js";
import { uploadAudioBlob } from "./js/api.js";

/* ---------- DOM ---------- */
const screenConsent = document.getElementById("screen-consent");
const screenReady   = document.getElementById("screen-ready");
const screenContact = document.getElementById("screen-contact");

const consentCheck = document.getElementById("consentCheck");
const nickEl = document.getElementById("nick");
const birthYMEl = document.getElementById("birthYM");
const nativeLangEl = document.getElementById("nativeLang");
const otherLangsEl = document.getElementById("otherLangs");
const btnStart = document.getElementById("btnStart");
const loadingEl = document.getElementById("loading");

const btnContinue = document.getElementById("btnContinue");
const contactValueEl = document.getElementById("contactValue");
const btnSubmitContact = document.getElementById("btnSubmitContact");

const ITEMS_CSV = "./stim/items_test.csv";
const PAIRS_CSV = "./stim/pairs_test.csv";
  
let STUDY_ITEMS = [];
let PRIMING_TRIALS = [];
  
const screenStudy = document.getElementById("screen-study");
const studyProgressEl = document.getElementById("studyProgress");
const fixationEl = document.getElementById("fixation");
const studyImgEl = document.getElementById("studyImg");
const studyLabelEl = document.getElementById("studyLabel");
const btnStartStudy = document.getElementById("btnStartStudy");
const btnNextAfterStudy = document.getElementById("btnNextAfterStudy");


const STUDY_TIMING = {
  fixation: 150,
  picOnly: 500,
  picPlusLabel: 500,
  iti: 50
};

const screenAFC = document.getElementById("screen-afc");
const afcImgEl = document.getElementById("afcImg");
const afcChoicesEl = document.getElementById("afcChoices");
const afcProgressEl = document.getElementById("afcProgress");
const afcTimerEl = document.getElementById("afcTimer");
const btnNextAFC = document.getElementById("btnNextAFC");

const AFC_THRESHOLD = 0.80; // 80%

const screenAfcResult = document.getElementById("screen-afc-result");
const afcResultTextEl = document.getElementById("afcResultText");
const btnAfcRemedial = document.getElementById("btnAfcRemedial");
const btnAfcProceed = document.getElementById("btnAfcProceed");

let VOICE_THRESHOLD = 0.02; // ê¸°ë³¸ê°’, ìº˜ë¦¬ë¸Œë ˆì´ì…˜ìœ¼ë¡œ ì¬ì„¤ì •

const screenMic = document.getElementById("screen-mic");
const micTextEl = document.getElementById("micText");
const micMeterEl = document.getElementById("micMeter");
const micLevelTextEl = document.getElementById("micLevelText");
const btnMicStart = document.getElementById("btnMicStart");
const btnMicNext = document.getElementById("btnMicNext");

const animacyButtonsEl = document.getElementById("animacyButtons");
const btnAnimate = document.getElementById("btnAnimate");
const btnInanimate = document.getElementById("btnInanimate");
    
let audioCtx = null;
let analyser = null;
let micStream = null;
  
let primeRecorder = null;
let primeChunks = [];

  /* =========================
   Study ì‹¤í–‰ ì—”ì§„
   ========================= */
  
async function initMic() {
  micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const source = audioCtx.createMediaStreamSource(micStream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  source.connect(analyser);
}

async function loadCSV(path) {
  const res = await fetch(path);
  if (!res.ok) {
    throw new Error(`CSV load failed: ${path}`);
  }

  const text = await res.text();
  const lines = text.trim().split(/\r?\n/);
  const headers = lines[0].split(",").map(h => h.trim());

  return lines.slice(1).map(line => {
    const cells = line.split(",").map(c => c.trim());
    const obj = {};
    headers.forEach((h, i) => {
      obj[h] = cells[i] ?? "";
    });
    return obj;
  });
}

async function loadItemsFromCSV() {
  const rows = await loadCSV(ITEMS_CSV);
  const items = {};

  rows.forEach(r => {
    if (!r.itemId) return;

    items[r.itemId] = {
      itemId: r.itemId,
      word: r.word,
      img: "./stim/" + r.img,   // CSVì—ëŠ” íŒŒì¼ëª…ë§Œ
      animacy: r.animacy || ""
    };
  });

  if (Object.keys(items).length === 0) {
    throw new Error("No items loaded from ITEMS_CSV");
  }

  return items;
}

async function loadPairSpecsFromCSV() {
  const rows = await loadCSV(PAIRS_CSV);

  return rows.map(r => ({
    sharedUnit: r.sharedUnit,
    primeId: r.primeId,
    targetId: r.targetId
  }));
}

async function loadAllStimuli() {
  const ITEMS = await loadItemsFromCSV();
  const PAIR_SPECS = await loadPairSpecsFromCSV();

  const STUDY_ITEMS = buildStudyItemsFromPairs(PAIR_SPECS, ITEMS);
  const PRIMING_TRIALS_RAW = buildPrimingTrials(PAIR_SPECS, ITEMS);
  const PRIMING_TRIALS = shuffleNoRepeatTarget(PRIMING_TRIALS_RAW);

  console.log("Loaded items:", STUDY_ITEMS.length);
  console.log("Priming trials:", PRIMING_TRIALS.length);
  console.log("Shared units:", [...new Set(PRIMING_TRIALS.map(t => t.sharedUnit))]);

  return {
    ITEMS,
    STUDY_ITEMS,
    PRIMING_TRIALS
  };
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function buildStudyItemsFromPairs(pairSpecs, itemsMap) {
  const usedIds = new Set();

  pairSpecs.forEach(p => {
    usedIds.add(p.primeId);
    usedIds.add(p.targetId);
  });

  const studyItems = [];
  const missing = [];

  usedIds.forEach(id => {
    if (!itemsMap[id]) {
      missing.push(id);
    } else {
      studyItems.push(itemsMap[id]);
    }
  });

  if (missing.length) {
    throw new Error("Missing itemId(s) in items.csv: " + missing.join(", "));
  }

  return studyItems;
}

function getCurrentRMS() {
  const buf = new Uint8Array(analyser.fftSize);
  analyser.getByteTimeDomainData(buf);
  let sum = 0;
  for (let i = 0; i < buf.length; i++) {
    const v = (buf[i] - 128) / 128;
    sum += v * v;
  }
  return Math.sqrt(sum / buf.length);
}

async function runMicCalibration() {
  micTextEl.innerHTML =
    "1) ë¨¼ì € <b>ë§í•˜ì§€ ë§ê³ </b> ì¡°ìš©íˆ ìˆì–´ ì£¼ì„¸ìš”.<br>" +
    "2) ë‹¤ìŒ ì•ˆë‚´ê°€ ë‚˜ì˜¤ë©´ <b>â€˜ê°€â€™</b>ë¥¼ í•œ ë²ˆ ë§í•´ ì£¼ì„¸ìš”.";

  btnMicStart.classList.remove("hidden");
  btnMicNext.classList.add("hidden");
  btnMicStart.disabled = false;

  btnMicStart.onclick = async () => {
    btnMicStart.disabled = true;
    btnMicStart.textContent = "ë§ˆì´í¬ ì¤€ë¹„ ì¤‘â€¦";

    try {
      await initMic(); // ê¶Œí•œ + analyser ì¤€ë¹„

      // ---- noise floor ----
      micTextEl.innerHTML = "ì§€ê¸ˆì€ <b>ë§í•˜ì§€ ë§ˆì„¸ìš”</b> (1ì´ˆ)â€¦";
      let noiseSamples = [];
      const t0 = performance.now();
      while (performance.now() - t0 < 1200) {
        const rms = getCurrentRMS();
        noiseSamples.push(rms);
        micMeterEl.value = Math.min(1, rms * 10);
        micLevelTextEl.textContent = `ì…ë ¥ ë ˆë²¨: ${rms.toFixed(4)}`;
        await sleep(60);
      }
      const noise = median(noiseSamples);

      // ---- speak prompt ----
      micTextEl.innerHTML = "<b>â€˜ê°€â€™</b>ë¥¼ í•œ ë²ˆ ë§í•´ ì£¼ì„¸ìš” (2ì´ˆ)â€¦";
      let speakSamples = [];
      const t1 = performance.now();
      while (performance.now() - t1 < 1800) {
        const rms = getCurrentRMS();
        speakSamples.push(rms);
        micMeterEl.value = Math.min(1, rms * 10);
        micLevelTextEl.textContent = `ì…ë ¥ ë ˆë²¨: ${rms.toFixed(4)}`;
        await sleep(30);
      }
      const peak = Math.max(...speakSamples);

      // threshold ê³„ì‚°
      const thrByNoise = Math.max(0.01, noise * 3.0);
      const thrByPeak = peak * 0.25;
      VOICE_THRESHOLD = clamp(thrByPeak, thrByNoise, 0.20);

      micTextEl.innerHTML =
        `ë§ˆì´í¬ í™•ì¸ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.<br>` +
        `ê°ì§€ ì„ê³„ì¹˜(ìë™ ì„¤ì •): <b>${VOICE_THRESHOLD.toFixed(3)}</b><br>` +
        `ì´ì œ ë³¸ ì‹¤í—˜ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;

      btnMicStart.classList.add("hidden");
      btnMicNext.classList.remove("hidden");

    } catch (e) {
      btnMicStart.disabled = false;
      btnMicStart.textContent = "ë§ˆì´í¬ ê¶Œí•œ í™•ì¸";
      alert("ë§ˆì´í¬ ì„¤ì • ì¤‘ ì˜¤ë¥˜:\n" + e.message);
    }
  };

  btnMicNext.onclick = async () => {
    hide(screenMic);
    await runPrimingExperiment(PRIMING_TRIALS); // priming ì‹œì‘
  };
}

function clamp(x, lo, hi) { return Math.min(hi, Math.max(lo, x)); }

function median(arr) {
  const a = arr.slice().sort((x,y)=>x-y);
  const mid = Math.floor(a.length/2);
  return a.length % 2 ? a[mid] : (a[mid-1]+a[mid])/2;
}

function buildPrimingTrials(pairSpecs, itemsMap) {
  const trials = [];
  const missing = new Set();

  pairSpecs.forEach((p, idx) => {
    const prime = itemsMap[p.primeId];
    const target = itemsMap[p.targetId];

    if (!prime) missing.add(p.primeId);
    if (!target) missing.add(p.targetId);

    trials.push({
      trialId: `T${String(idx + 1).padStart(4, "0")}`,
      sharedUnit: p.sharedUnit,

      primeId: p.primeId,
      targetId: p.targetId,

      primeWord: prime?.word || "",
      targetWord: target?.word || "",

      primeImg: prime?.img || "",
      targetImg: target?.img || "",

      primeAnimacy: prime?.animacy || "",
      targetAnimacy: target?.animacy || ""
    });
  });

  if (missing.size) {
    throw new Error(
      "PAIR_SPECS refers to missing itemId(s): " +
      [...missing].join(", ")
    );
  }

  return trials;
}

function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function shuffleNoRepeatTarget(trials, maxTries = 2000) {
  for (let i = 0; i < maxTries; i++) {
    const s = shuffle(trials);
    let ok = true;
    for (let j = 1; j < s.length; j++) {
      if (s[j].targetId === s[j - 1].targetId) {
        ok = false;
        break;
      }
    }
    if (ok) return s;
  }
  console.warn("Target repeat constraint failed, using simple shuffle.");
  return shuffle(trials);
}


async function runStudyPass(passNum, items) {
  const order = shuffle(items);
  for (let t = 0; t < order.length; t++) {
    const it = order[t];
    studyProgressEl.textContent = `í•™ìŠµ ${passNum}/1 â€” ${t+1}/${order.length}`;

    fixationEl.classList.remove("hidden");
    studyImgEl.classList.add("hidden");
    studyLabelEl.classList.add("hidden");
    await sleep(150);

    fixationEl.classList.add("hidden");
    studyImgEl.src = it.img;
    studyImgEl.classList.remove("hidden");
    await sleep(450);

    studyLabelEl.textContent = it.word;
    studyLabelEl.classList.remove("hidden");
    await sleep(450);

    studyImgEl.classList.add("hidden");
    studyLabelEl.classList.add("hidden");
    await sleep(150);
  }
}


async function runStudy2Passes() {
  // ğŸ”’ í•™ìŠµ ì¤‘ ë²„íŠ¼ ìˆ¨ê¹€
  btnStartStudy.classList.add("hidden");
  btnNextAfterStudy.classList.add("hidden");
  
  btnStartStudy.disabled = true;
  btnStartStudy.textContent = "í•™ìŠµ ì§„í–‰ ì¤‘â€¦";

  // ---- ì—¬ê¸°ì„œë¶€í„° ì‹¤ì œ í•™ìŠµ ----
  await runStudyPass(1, STUDY_ITEMS);
  await sleep(300);
  await runStudyPass(2, STUDY_ITEMS);

  // ---- í•™ìŠµ ì¢…ë£Œ ì²˜ë¦¬ ----
  studyProgressEl.textContent =
  "í•™ìŠµì´ ëë‚¬ìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™í•´ ì£¼ì„¸ìš”.";
  
  // ğŸ‘‰ ì—¬ê¸°ì„œ ë‹¤ìŒ ë²„íŠ¼ ë“±ì¥
  btnStartStudy.classList.add("hidden");
  btnNextAfterStudy.classList.remove("hidden");
  btnNextAfterStudy.disabled = false;


}
  
function getRandomDistractors(correctItem, allItems, n = 3) {
  const pool = allItems.filter(it => it.itemId !== correctItem.itemId);
  const shuffled = shuffle(pool);
  return shuffled.slice(0, n);
}

/* ---------- STATE ---------- */
let assignedGroup = null;   // overt / covert / nonaming (ì°¸ê°€ìì—ê²Œ ì•ˆ ë³´ì„)
let session = null;

/* ---------- UTIL ---------- */
const show = el => el.classList.remove("hidden");
const hide = el => el.classList.add("hidden");

function generatePid() {
  const d = new Date();
  return "P" +
    d.toISOString().replace(/[-:.TZ]/g,"") +
    "-" + Math.random().toString(36).slice(2,6).toUpperCase();
}

function validateForm() {
  btnStart.disabled = !(
    consentCheck.checked &&
    nickEl.value.trim().length >= 2 &&
    /^\d{4}-\d{2}$/.test(birthYMEl.value) &&
    nativeLangEl.value.trim() &&
    otherLangsEl.value.trim()
  );
}

const AFC_TIME_LIMIT = 2000; // 2ì´ˆ
let afcOrder = [];
let afcIndex = 0;
let afcTimer = null;

function startAFC(items, phaseName) {
  afcPhaseName = phaseName;     // "afc1" or "afc2"
  afcResponses = [];            // ìƒˆ phase ì‹œì‘ ì‹œ ì´ˆê¸°í™”
  afcOrder = shuffle(items);
  afcIndex = 0;

  appendRow({
    event: "afc_start",
    ts_iso: new Date().toISOString(),
    pid: session.pid,
    sessionId: session.sessionId,
    phase: afcPhaseName
  });

  runNextAFCTrial();
}


function runNextAFCTrial() {
  if (afcIndex >= afcOrder.length) {
    endAFC();
    return;
  }

  const it = afcOrder[afcIndex];
  afcProgressEl.textContent =
    `ë¬¸í•­ ${afcIndex + 1} / ${afcOrder.length}`;

  afcImgEl.src = it.img;

  // ì„ íƒì§€ êµ¬ì„±
  const distractors = getRandomDistractors(it, STUDY_ITEMS, 3);
  const options = shuffle([
    { word: it.word, correct: true },
    ...distractors.map(d => ({ word: d.word, correct: false }))
  ]);

  afcChoicesEl.innerHTML = "";
  const trialStart = Date.now();
  
  let answered = false;

  options.forEach(opt => {
    const btn = document.createElement("button");
    btn.textContent = opt.word;
    btn.onclick = () => {
      if (answered) return;
      answered = true;
      clearInterval(afcTimer);
      lockAFCTrial(opt, trialStart);
    };
    afcChoicesEl.appendChild(btn);
  });

  let remaining = AFC_TIME_LIMIT;
  afcTimerEl.textContent = `ë‚¨ì€ ì‹œê°„: ${remaining} ms`;

  afcTimer = setInterval(() => {
    remaining -= 100;
    afcTimerEl.textContent = `ë‚¨ì€ ì‹œê°„: ${remaining} ms`;
  
    if (remaining <= 0) {
      clearInterval(afcTimer);
      lockAFCTrial(null, trialStart); // â¬… ìë™ ì§„í–‰ X
    }
  }, 100);
}

function endAFC() {
  appendRow({
    event: "afc_end",
    ts_iso: new Date().toISOString(),
    pid: session.pid,
    sessionId: session.sessionId,
    phase: afcPhaseName
  });

  // --- ì •í™•ë„ ê³„ì‚° ---
  const total = afcResponses.length;
  const nCorrect = afcResponses.filter(r => r.correct).length;
  const acc = total ? (nCorrect / total) : 0;

  // ì˜¤ë‹µ ì•„ì´í…œ ëª©ë¡(afc1ì—ì„œë§Œ ì‚¬ìš©)
  if (afcPhaseName === "afc1") {
    const wrongIds = new Set(afcResponses.filter(r => !r.correct).map(r => r.itemId));
    afcWrongItems = STUDY_ITEMS.filter(it => wrongIds.has(it.itemId));
  }

  // --- ê²°ê³¼ í™”ë©´ í‘œì‹œ ---
  hide(screenAFC);
  show(screenAfcResult);

  const pct = Math.round(acc * 100);
  if (acc >= AFC_THRESHOLD) {
    afcResultTextEl.innerHTML =
      `ì •í™•ë„: <b>${pct}%</b><br><br>` +
      `í™•ì¸ í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•´ ì£¼ì„¸ìš”.`;

    btnAfcProceed.classList.remove("hidden");
    btnAfcRemedial.classList.add("hidden");
  } else {
    // ê¸°ì¤€ ë¯¸ë‹¬
    if (afcPhaseName === "afc1" && !remedialUsed) {
      afcResultTextEl.innerHTML =
        `ì •í™•ë„: <b>${pct}%</b><br><br>` +
        `ê¸°ì¤€ì— ë¯¸ë‹¬í•˜ì—¬, <b>í‹€ë¦° í•­ëª©ë§Œ</b> ë‹¤ì‹œ í•™ìŠµí•œ ë’¤ ì¬ì‹œí—˜ì„ ì§„í–‰í•©ë‹ˆë‹¤.`;

      btnAfcRemedial.classList.remove("hidden");
      btnAfcProceed.classList.add("hidden");
    } else {
      // ì¬ì‹œí—˜(afc2)ì—ì„œë„ ë¯¸ë‹¬ì´ë©´ ì¢…ë£Œ ì²˜ë¦¬(ì›í•˜ë©´ ë‹¤ë¥¸ ì •ì±… ê°€ëŠ¥)
      afcResultTextEl.innerHTML =
        `ì •í™•ë„: <b>${pct}%</b><br><br>` +
        `ì•„ì‰½ì§€ë§Œ ê¸°ì¤€ì— ë¯¸ë‹¬í•˜ì—¬ ì‹¤í—˜ì„ ê³„ì† ì§„í–‰í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤.<br>` +
        `ì°¸ì—¬í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤.`;

      btnAfcRemedial.classList.add("hidden");
      btnAfcProceed.classList.add("hidden");
      
      // ğŸ”’ ì—°ë½ì²˜ í™”ë©´ìœ¼ë¡œ ë³´ë‚´ì§€ ì•ŠìŒ
      // (ì›í•˜ë©´ 3ì´ˆ í›„ ìë™ ì¢…ë£Œ)
      setTimeout(() => {
        window.location.href = "about:blank";
      }, 3000);
    }
  }
}


function lockAFCTrial(opt, trialStart) {
  const it = afcOrder[afcIndex];
  
  const rt = opt ? (Date.now() - trialStart) : null;
  const correct = opt ? opt.correct : false;
  const responseWord = opt ? opt.word : "";
  const timeout = opt === null;

  // ë²„íŠ¼ ì „ë¶€ ë¹„í™œì„±í™”
  [...afcChoicesEl.children].forEach(b => b.disabled = true);

  afcTimerEl.textContent = timeout
    ? "ì‹œê°„ ì´ˆê³¼ â€” ë‹¤ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì£¼ì„¸ìš”."
    : "ì‘ë‹µì´ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.";
  
  // âœ… ë©”ëª¨ë¦¬ ëˆ„ì  (ì •í™•ë„ ê³„ì‚°ìš©)
  afcResponses.push({
    itemId: it.itemId,
    targetWord: it.word,
    responseWord,
    correct,
    timeout,
    rt_ms: rt
  });

  // ê²°ê³¼ ì €ì¥ (ì—¬ê¸°ì„œë¶€í„° í•µì‹¬ ë°ì´í„°)
  appendRow({
    event: "afc_trial",
    ts_iso: new Date().toISOString(),
    pid: session.pid,
    sessionId: session.sessionId,
    primeModeGroup: assignedGroup,
    phase: afcPhaseName,            // â˜… "afc1" / "afc2"
    trialIndex_phase: afcIndex + 1,
    itemId: it.itemId,
    targetWord: it.word,
    responseWord,
    correct,
    timeout,
    rt_ms: rt
  });

  // Next ë²„íŠ¼ í™œì„±í™”
  btnNextAFC.classList.remove("hidden");
  btnNextAFC.disabled = false;
}

let afcPhaseName = "afc1";           // "afc1" ë˜ëŠ” "afc2"
let afcResponses = [];               // í˜„ì¬ phase ì‘ë‹µ ëˆ„ì 
let afcWrongItems = [];              // afc1 ì˜¤ë‹µ item ë¦¬ìŠ¤íŠ¸
let remedialUsed = false;            // ì˜¤ë‹µ ì¬í•™ìŠµ/ì¬ì‹œí—˜ì€ 1ë²ˆë§Œ

function setPrimingInstruction() {
  const el = document.getElementById("primingInstruction");

  if (assignedGroup === "overt") {
    el.innerHTML =
      "ì²« ë²ˆì§¸ ê·¸ë¦¼ì´ ë‚˜ì˜¤ë©´ <b>ë‹¨ì–´ë¥¼ ì†Œë¦¬ ë‚´ì–´ ë§í•˜ê³ </b>,<br>" +
      "ì´ì–´ì§€ëŠ” ë‘ ë²ˆì§¸ ê·¸ë¦¼ë„ <b>ë¹ ë¥´ê²Œ ë§í•´ ì£¼ì„¸ìš”</b>.";
  } else if (assignedGroup === "covert") {
    el.innerHTML =
      "ì²« ë²ˆì§¸ ê·¸ë¦¼ì€ <b>ì†ìœ¼ë¡œ ë‹¨ì–´ë¥¼ ë– ì˜¬ë¦¬ê³ </b>,<br>" +
      "ë‘ ë²ˆì§¸ ê·¸ë¦¼ì€ <b>ì†Œë¦¬ ë‚´ì–´ ë§í•´ ì£¼ì„¸ìš”</b>.";
  } else {
    el.innerHTML =
      "ì²« ë²ˆì§¸ ê·¸ë¦¼ì€ <b>ê·¸ëƒ¥ ë³´ê³  ì§€ë‚˜ê°€ê³ </b>,<br>" +
      "ë‘ ë²ˆì§¸ ê·¸ë¦¼ë§Œ <b>ì†Œë¦¬ ë‚´ì–´ ë§í•´ ì£¼ì„¸ìš”</b>.";
  }
}


function detectVoiceOnset(maxMs = 2000, threshold = VOICE_THRESHOLD) {
  return new Promise(resolve => {
    const start = performance.now();
    const buf = new Uint8Array(analyser.fftSize);

    function tick() {
      analyser.getByteTimeDomainData(buf);
      let sum = 0;
      for (let i = 0; i < buf.length; i++) {
        const v = (buf[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / buf.length);

      if (rms > threshold) {
        resolve(Math.round(performance.now() - start));
      } else if (performance.now() - start >= maxMs) {
        resolve(null); // timeout
      } else {
        requestAnimationFrame(tick);
      }
    }
    tick();
  });
}

function getAnimacyResponseMustClick() {
  return new Promise(resolve => {
    const done = (resp) => {
      cleanup();
      resolve(resp);
    };
    const cleanup = () => {
      btnAnimate.onclick = null;
      btnInanimate.onclick = null;
    };
    btnAnimate.onclick = () => done("animate");
    btnInanimate.onclick = () => done("inanimate");
  });
}

async function requireVoiceOnsetOrRetry({windowMs=3000, retries=1}) {
  for (let k = 0; k <= retries; k++) {
    const onset = await detectVoiceOnset(windowMs); // ë„ˆì˜ ì•ˆì •í™”ëœ detectVoiceOnset ë²„ì „ ì‚¬ìš©
    if (onset !== null) return { onset_ms: onset, attempts: k+1, gaveUp: false };

    // ì‹¤íŒ¨ â†’ ì¬ì‹œë„ ì•ˆë‚´
    if (k < retries) {
      primingStatus.textContent = "ë§í•´ ì£¼ì„¸ìš”. (ë§ˆì´í¬ê°€ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤)";
      await sleep(600);
      primingStatus.textContent = "ë§í•˜ì„¸ìš”";
      await sleep(200);
    }
  }
  return { onset_ms: null, attempts: retries+1, gaveUp: true };
}
  
async function runPrimingTrial(trial) {
  const fixEl = document.getElementById("primingFixation");
  const imgEl = document.getElementById("primingImg");
  const statusEl = document.getElementById("primingStatus");

  let primeVoiceRT = null;
  let primeAudioBlob = null;
  let primeAudioFileId = "";
  let primeSpoken = null;
  let primeCheckReason = null;
  let animacyResp = null;
  let animacyRT = null;

  /* ---------- Fixation ---------- */
  imgEl.classList.add("hidden");
  fixEl.classList.remove("hidden");
  await sleep(300);

  /* ---------- Prime ---------- */
  fixEl.classList.add("hidden");
  imgEl.src = trial.primeImg;
  imgEl.classList.remove("hidden");

  if (assignedGroup === "overt") {
    statusEl.textContent = "ë§í•˜ì„¸ìš”";

    const res = await recordPrimeWithVoiceKey(2000);
    primeVoiceRT = res.prime_voice_rt_ms;
    primeAudioBlob = res.audio_blob;

    const evalRes = evaluatePrimeAudio(primeAudioBlob, primeVoiceRT);
    primeSpoken = evalRes.spoken;
    primeCheckReason = evalRes.reason;

    // ğŸ”¹ 15% ëœë¤ ì—…ë¡œë“œ
    if (primeAudioBlob) {
      const meta = {
        pid: session.pid,
        sessionId: session.sessionId,
        folderId: session.folderId,
        filename: `${session.pid}_${trial.trialId}_prime_${Date.now()}.webm`,
        mimeType: "audio/webm",
        type: "prime",
        trialId: trial.trialId,
        phase: "priming"
      };
      console.log("UPLOAD TRY", meta, primeAudioBlob.size);
    
      try {
        const out = await uploadAudioBlob(primeAudioBlob, meta);
        console.log("UPLOAD OK", out);
        primeAudioFileId = out.fileId || "";
      } catch (e) {
        console.error("Prime audio upload failed:", e);
      }
    }

  } else if (assignedGroup === "covert") {
    statusEl.textContent = "ì†ìœ¼ë¡œ ë§í•˜ì„¸ìš”";
    await sleep(2000);

  } else {
    // no-naming: animacy decision
    statusEl.textContent = "ìƒë¬¼ì¸ì§€ ë¬´ìƒë¬¼ì¸ì§€ ì„ íƒí•˜ì„¸ìš”";
    animacyButtonsEl.classList.remove("hidden");
    const aStart = performance.now();
    animacyResp = await getAnimacyResponseMustClick();
    const animacyRT = Math.round(performance.now() - aStart);
    animacyButtonsEl.classList.add("hidden");
  }

  /* ---------- ISI ---------- */
  imgEl.classList.add("hidden");
  statusEl.textContent = "";
  await sleep(150);

  /* ---------- Target ---------- */
  imgEl.src = trial.targetImg;

  statusEl.textContent = "ë§í•˜ì„¸ìš”";
  const target_display_ts = new Date().toISOString();

  // âœ… targetRecì„ ë°˜ë“œì‹œ ì„ ì–¸
  const targetRec = await recordWindow(3000);   // recordWindowê°€ { onset_ms, blob } ë¦¬í„´í•œë‹¤ê³  ê°€ì •
  const targetRT = targetRec.onset_ms;          // nullì´ë©´ timeout
  const vr = await requireVoiceOnsetOrRetry({ windowMs: 3000, retries: 1 });
  const targetAttempts = vr.attempts;
  const targetGaveUp = vr.gaveUp;

  
  // âœ… target ì—…ë¡œë“œ: 10% ìƒ˜í”Œ + ë§í•œ ê²½ìš°ë§Œ
  let targetAudioFileId = "";
  
  if (targetRec.blob && targetRec.blob.size > 1500 && targetRT !== null && Math.random() < 0.10) {
    const meta = {
      pid: session.pid,
      sessionId: session.sessionId,
      folderId: session.folderId,
      filename: `${session.pid}_${trial.trialId}_target_${Date.now()}.webm`,
      mimeType: "audio/webm",
      type: "target",
      trialId: trial.trialId,
      phase: "priming"
    };
    try {
      const up = await uploadAudioBlob(targetRec.blob, meta);
      targetAudioFileId = up.fileId || "";
    } catch (e) {
      console.error("Target audio upload failed:", e);
    }
  }
  
  imgEl.classList.remove("hidden");
  
  /* ---------- ì €ì¥ ---------- */
  trialIndexGlobal++;

  await appendRow({
    event: "priming_trial",
    ts_iso: new Date().toISOString(),
    pid: session.pid,
    sessionId: session.sessionId,
    folderId: session.folderId,
    phase: "priming",
    primeModeGroup: assignedGroup,
  
    trialIndex_global: trialIndexGlobal,
    trialIndex_phase: i + 1,              // runPrimingExperimentì—ì„œ ië¥¼ ë„˜ê²¨ì£¼ê±°ë‚˜ trialIndexGlobalë§Œ ì¨ë„ ë¨
  
    trialId: trial.trialId,
    sharedUnit: trial.sharedUnit,
  
    primeItemId: trial.primeId,
    targetItemId: trial.targetId,
  
    primeWord: trial.primeWord,
    targetWord: trial.targetWord,
  
    primeImg: trial.primeImg,
    targetImg: trial.targetImg,
  
    target_display_ts: target_display_ts,
  
    // í‘œì¤€ ì´ë¦„ìœ¼ë¡œ í†µì¼
    prime_voiceKeyRT_ms: primeVoiceRT ?? "",
    target_voiceKeyRT_ms: targetRT ?? "",
  
    // no-naming ì¡°ì‘
    animacy_response: animacyResp ?? "",
    animacy_rt_ms: animacyRT ?? "",
  
    // ì—…ë¡œë“œí•œ ê²½ìš°ë§Œ
    prime_audio_fileId: primeAudioFileId ?? "",
    target_audio_fileId: targetAudioFileId ?? "",
  
    // í’ˆì§ˆ/íƒ€ì„ì•„ì›ƒ
    timeout: (targetRT === null),
    target_attempts: targetAttempts,
    target_gaveUp: targetGaveUp,
  
    // prime check
    prime_spoken: primeSpoken ?? "",
    prime_check_reason: primeCheckReason ?? ""
  });

  /* ---------- ITI ---------- */
  imgEl.classList.add("hidden");
  statusEl.textContent = "";
  await sleep(400);
}

async function recordWindow(maxMs = 2000, threshold = VOICE_THRESHOLD) {
  const chunks = [];
  const recorder = new MediaRecorder(micStream, { mimeType: "audio/webm;codecs=opus" });

  recorder.ondataavailable = e => { if (e.data && e.data.size > 0) chunks.push(e.data); };
  recorder.start(250); // timeslice: ì§§ì€ ë…¹ìŒì—ì„œ blob ë¹„ëŠ” ë¬¸ì œ ë°©ì§€

  const onset = await detectVoiceOnset(maxMs, threshold);

  // ìœˆë„ìš° ëê¹Œì§€ ë…¹ìŒ ìœ ì§€(ì›í•˜ë©´ onset+300ms ê°™ì€ ì •ì±…ë„ ê°€ëŠ¥)
  await sleep( Math.max(0, maxMs - (onset ?? maxMs)) );

  recorder.stop();
  await new Promise(r => recorder.onstop = r);

  const blob = new Blob(chunks, { type: "audio/webm" });
  return { onset_ms: onset, blob };
}
  
async function runPrimingExperiment(trials) {
  hide(screenAfcResult);
  show(document.getElementById("screen-priming"));

  setPrimingInstruction();

  await initMic(); // ğŸ”’ ë§ˆì´í¬ 1íšŒ ì´ˆê¸°í™”

  for (let i = 0; i < trials.length; i++) {
    await runPrimingTrial(trials[i]);
  }

  // ì¢…ë£Œ â†’ ì—°ë½ì²˜ í™”ë©´
  hide(document.getElementById("screen-priming"));
  show(screenContact);
}
  
async function recordPrimeWithVoiceKey(maxMs = 1200, threshold = 0.02) {
  primeChunks = [];

  const recorder = new MediaRecorder(micStream, {
    mimeType: "audio/webm;codecs=opus"
  });
  primeRecorder = recorder;

  recorder.ondataavailable = e => {
    if (e.data && e.data.size > 0) primeChunks.push(e.data);
  };

  recorder.start();

  const onset = await detectVoiceOnset(maxMs, threshold);

  recorder.stop();

  const blob = new Blob(primeChunks, { type: "audio/webm" });

  return {
    prime_voice_rt_ms: onset,        // nullì´ë©´ ë°œí™” ì—†ìŒ
    audio_blob: blob,
    audio_size: blob.size
  };
}

function evaluatePrimeAudio(audioBlob, onsetMs) {
  if (!audioBlob || onsetMs === null) {
    return { spoken: false, reason: "no_onset" };
  }

  // ë„ˆë¬´ ì§§ì€ ë°œí™”(í—›ê¸°ì¹¨/ë…¸ì´ì¦ˆ)
  if (audioBlob.size < 1500) {
    return { spoken: false, reason: "too_short" };
  }

  // ë°œí™” onsetì´ prime ëì— ë„ˆë¬´ ê°€ê¹Œì›€
  if (onsetMs > 1000) {
    return { spoken: false, reason: "late_onset" };
  }

  return { spoken: true, reason: "ok" };
}

function openAudioDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("audioDB", 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains("blobs")) {
        db.createObjectStore("blobs", { keyPath: "key" });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbPut(key, blob, meta) {
  const db = await openAudioDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction("blobs", "readwrite");
    tx.objectStore("blobs").put({ key, blob, meta });
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

async function idbDelete(key) {
  const db = await openAudioDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction("blobs", "readwrite");
    tx.objectStore("blobs").delete(key);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

const uploadQueue = [];
let uploading = false;

function enqueueUpload(key, blob, meta) {
  uploadQueue.push({ key, blob, meta });
  pumpUploadQueue();
}

async function pumpUploadQueue() {
  if (uploading) return;
  uploading = true;

  while (uploadQueue.length > 0) {
    const job = uploadQueue.shift();
    try {
      await uploadAudioBlob(job.blob, job.meta);
      await idbDelete(job.key);
      // ì„±ê³µ ë¡œê·¸(ì„ íƒ)
      appendRow({
        event:"audio_upload_ok",
        ts_iso:new Date().toISOString(),
        pid: job.meta.pid,
        sessionId: job.meta.sessionId,
        audio_key: job.key,
        audio_type: job.meta.type,
        trialId: job.meta.trialId
      });
    } catch (e) {
      // ì‹¤íŒ¨í•˜ë©´ ë‹¤ì‹œ íì— ë„£ê³  íƒˆì¶œ(ì ê¹ ì‰¬ì—ˆë‹¤ ì¬ì‹œë„)
      uploadQueue.unshift(job);
      console.warn("upload failed, will retry:", e);
      await sleep(1500);
      break;
    }
  }

  uploading = false;
}




/* ---------- GROUP ASSIGNMENT (silent) ---------- */
async function assignPrimeMode() {
  try {
    const res = await jsonp({ action:"getGroupCounts" });
    const c = res.counts;
    const groups = ["overt","covert","nonaming"];
    const min = Math.min(...groups.map(g=>c[g]||0));
    const mins = groups.filter(g=>(c[g]||0)===min);
    return Math.random()<0.8
      ? mins[Math.floor(Math.random()*mins.length)]
      : groups[Math.floor(Math.random()*3)];
  } catch {
    return ["overt","covert","nonaming"][Math.floor(Math.random()*3)];
  }
}
assignPrimeMode().then(g=>assignedGroup=g);

/* ---------- EVENTS ---------- */
[consentCheck,nickEl,birthYMEl,nativeLangEl,otherLangsEl]
  .forEach(el=>{
    el.addEventListener("input",validateForm);
    el.addEventListener("change",validateForm);
  });

btnStart.onclick = async () => {
  btnStart.disabled = true;
  show(loadingEl);

  try {
    // âœ… ìê·¹ ë¡œë“œ (ì—¬ê¸°ì„œ ì‹¤íŒ¨í•˜ë©´ ë©”ì‹œì§€ ë„ìš°ê³  ë)
    const stim = await loadAllStimuli();
    STUDY_ITEMS = stim.STUDY_ITEMS;
    PRIMING_TRIALS = stim.PRIMING_TRIALS;

    const pid = generatePid();
    const participant = {
      nick: nickEl.value.trim(),
      birthYM: birthYMEl.value,
      nativeLang: nativeLangEl.value.trim(),
      otherLangs: otherLangsEl.value.trim()
    };
  
    session = await createSession(pid, {
      primeModeGroup: assignedGroup,
      participant
    });
  
    await appendRow({
      event:"participant_info",
      ts_iso:new Date().toISOString(),
      pid:session.pid,
      sessionId:session.sessionId,
      primeModeGroup:assignedGroup,
      participant_nick:participant.nick,
      participant_birthYM:participant.birthYM,
      participant_nativeLang:participant.nativeLang,
      participant_otherLangs:participant.otherLangs
    });
  
    hide(screenConsent);
    hide(loadingEl);
    show(screenReady);
  } catch (e) {
    hide(loadingEl);
    btnStart.disabled = false;
    alert("ìê·¹ íŒŒì¼ ë¡œë“œ/ì„¸ì…˜ ì¤€ë¹„ ì¤‘ ì˜¤ë¥˜:\n" + e.message);
  }
};

btnContinue.onclick = () => {
  hide(screenReady);
  show(screenStudy);
  btnStartStudy.classList.remove("hidden");
};

btnStartStudy.onclick = async () => {
  try {
    await runStudy2Passes();
    // TODO: ë‹¤ìŒ ë‹¨ê³„ (4AFC)ë¡œ í™”ë©´ ì „í™˜
  } catch (e) {
    alert("í•™ìŠµ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n" + e.message);
    btnStartStudy.disabled = false;
    btnStartStudy.textContent = "í•™ìŠµ ì‹œì‘";
  }
};

btnNextAfterStudy.onclick = () => {
  hide(screenStudy);
  show(screenAFC);
  startAFC(STUDY_ITEMS, "afc1");   // â˜… 1ì°¨ í…ŒìŠ¤íŠ¸ ì‹œì‘
};

btnAfcRemedial.onclick = async () => {
  remedialUsed = true;

  // ì˜¤ë‹µì´ 0ê°œë©´ ì‚¬ì‹¤ìƒ í†µê³¼ë¡œ ì²˜ë¦¬ ê°€ëŠ¥
  if (afcWrongItems.length === 0) {
    hide(screenAfcResult);
    // ë‹¤ìŒ ë‹¨ê³„ë¡œ
    btnAfcProceed.click();
    return;
  }

  // ì˜¤ë‹µë§Œ í•™ìŠµ 1íšŒ
  hide(screenAfcResult);
  show(screenStudy);

  // í•™ìŠµ ì¤‘ ë²„íŠ¼ ìˆ¨ê¹€
  btnStartStudy.classList.add("hidden");
  btnNextAfterStudy.classList.add("hidden");

  // ì•ˆë‚´ë¬¸ ì—…ë°ì´íŠ¸
  studyProgressEl.innerHTML =
    "í‹€ë¦° í•­ëª©ë§Œ ë‹¤ì‹œ í•™ìŠµí•©ë‹ˆë‹¤.<br>" +
    "ê·¸ë¦¼ê³¼ ë‹¨ì–´ë¥¼ ì˜ ë³´ê³  ê¸°ì–µí•´ ì£¼ì„¸ìš”.";

  await runStudyPass(1, afcWrongItems);

  // í•™ìŠµ ë â†’ ì¬ì‹œí—˜ ë²„íŠ¼(ì—¬ê¸°ì„œëŠ” ë°”ë¡œ ì¬ì‹œí—˜ìœ¼ë¡œ ê°€ëŠ” ë²„íŠ¼ì„ ì¬í™œìš©)
  studyProgressEl.textContent = "ì¬ì‹œí—˜ìœ¼ë¡œ ì´ë™í•´ ì£¼ì„¸ìš”.";
  btnNextAfterStudy.textContent = "ì¬ì‹œí—˜ ì‹œì‘";
  btnNextAfterStudy.classList.remove("hidden");

  btnNextAfterStudy.onclick = () => {
    hide(screenStudy);
    show(screenAFC);
    startAFC(afcWrongItems, "afc2");   // â˜… ì˜¤ë‹µë§Œ ì¬ì‹œí—˜
  };
};

btnAfcProceed.onclick = async () => {
  hide(screenAfcResult);
  show(screenMic);              // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í™”ë©´
  await runMicCalibration();    // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ëë‚˜ë©´ ìë™ìœ¼ë¡œ priming ì‹œì‘
};


btnSubmitContact.onclick = async () => {
  const phone = contactValueEl.value.trim();
  const phoneOk = /^01[016789]-?\d{3,4}-?\d{4}$/.test(phone);

  if (!phoneOk) {
    alert("ë³´ìƒ ê¸°í”„í‹°ì½˜ì„ ë°›ì„ íœ´ëŒ€í° ë²ˆí˜¸ë¥¼ ì •í™•íˆ ì…ë ¥í•´ ì£¼ì„¸ìš”.\nì˜ˆ: 010-1234-5678");
    return;
  }

  btnSubmitContact.disabled = true; // ğŸ”’ ì ê¸ˆ

  try {
    await jsonp({
      action: "appendContact",
      contact_json: JSON.stringify({
        pid: session.pid,
        sessionId: session.sessionId,
        contact_type: "phone",
        contact_value: phone
      })
    });

    alert("ì œì¶œì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì°¸ì—¬í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤!");
    window.location.href = "about:blank";

  } catch (e) {
    btnSubmitContact.disabled = false; // ì‹¤íŒ¨ ì‹œ ë³µêµ¬
    alert("ì—°ë½ì²˜ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n" + e.message);
  }
};

btnNextAFC.onclick = () => {
btnNextAFC.classList.add("hidden");
afcIndex++;
runNextAFCTrial();
};

</script>
</body>
</html>
